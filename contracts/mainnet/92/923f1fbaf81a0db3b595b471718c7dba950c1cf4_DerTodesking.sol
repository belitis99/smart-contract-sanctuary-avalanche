// SPDX-License-Identifier: MIT
/*

@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@#GGBBGB&@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@BPP#@#GPB&@@&######@@@#######&@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@BPP#@@#[email protected]##GPG&@PPP#&#GGB&@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@BPP#@&BPG#@GPPBBBBBG&@[email protected]@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@&BBBBBBBB#@@@@@@@@@@@@@@@@@@@@@BPPGBPB#@@@&BPB#BB#@@@[email protected]@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@&&#PPG&&&@@@&&&&&&@@@@@@@@@BGG#&&&##&&&@@@@&#####&&&&BPG#@@@@@@@@&BB#@@@&&&&&&&@@@@@&&&&&&&&@@@
@@@@@@@&[email protected]@@@&BPG##GPB&@@&####GPP#@#BPB#BPG#@&#GG####B#@[email protected]###@@@#####@@&PPPBBBPG#@&#GG##[email protected]@@
@@@@@@@&[email protected]@@@BPP#@@#PPB&BGP#&&GPP#@PPPBBBGGG&&&BGBBBB#@@BPPGBPG#@@@&[email protected]@&[email protected]@@GPP&&[email protected]@&[email protected]@@
@@@@@@@#[email protected]@@@#GPB##BPG#!!YP#&&GPP#@BGP####&BY~B####BPG#@[email protected]#&#5^YPG#&&[email protected]@@GPP&@@#[email protected]@@
@@@@@@@&##&@@@@@@######@@P7:75####[email protected]@&######!::G######&@@&##&@@&J?J^~5B###&@###@@@###@&BBBBBBPB#@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@G~^~7BB7^[email protected]@@@&#[email protected]!^:&#!G&@@#7P&@@@@G!^^:[email protected]@@@@@@@@@@@@@@@@@&&&&&&&@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@~:^^^^:~5#@@Y^:7P~::YJ:^[email protected]@#:^~5#@G?::::[email protected]@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@BY:::::::!??~::::^~~::::^??7^:::!?^:::7G&@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@G:^^::^~::^^::::~!~^:::^^::~^::^^::::[email protected]@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@#555P!^^^^^^^:::^^^::::^^^^^^^^^[email protected]@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@&?^^^^^?P7!!^^~^^^^^^^^^^[email protected]@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@B:~!!!!?77YGBY?!?7!!!!!!^~!7?JG#@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@Y7~YPBBBBY!!5&[email protected]@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@!^PB#&&&##B!JB?JP##&&&&&##[email protected]@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@BY&@@@@@!~PB######B^?B7JG########&[email protected]@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@&#@@@@@@!~G##G#&&5!~Y#G5JPB&BB###&J^[email protected]@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@#P&@@@@@5JJP#&PYY?7PGG55PY5B##&&#57^[email protected]@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@P~&@@@@@@B:~!?~~JPBJP#GPPY5PJ7777^^^~7JB&@@@@@@@@@@@&[email protected]@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@&[email protected]@@@@#??7^^~YB&!Y&GY^~?G?!^^^[email protected]@@@@@@@@@@@@@&YJYB&@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@[email protected]@@@@@@@#~~~^7Y7?Y~^~^!J77?~^~~~^[email protected]@@@@@@@@@@@@BPYYYG#@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@&[email protected]@@@@@@@&YJJPY?G5?P5JP5JPP5!^^^!B&@@@@@@@@@@@@@[email protected]@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@&BGPYYYYYYYY5&&&&&&&&&&&&#B5!^^^[email protected]@@@@@@@@@@@@@@[email protected]@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@&#BBPPPPPPP7~G5JGPYGPYGPY?!^[email protected]@@@@@@@@@@@@@@[email protected]@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@Y^~~^~~^~~^~~~?J?B&&@@@@@@@@@@@@@@@@@[email protected]@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@BPPPPPPPPPP??P&@@@@@@@@@@@@@@@@@@@@@@[email protected]@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@[email protected]@@@@@@@@@@@@@@@@@[email protected]@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@&[email protected]@@@@@@@@[email protected]@@@@@@@@[email protected]@@@@@[email protected]@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@&&&PJ!!!JJY&&&@@@[email protected]@@&&#JJJ!~~YG&@#[email protected]@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@[email protected]#[email protected]@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@?!!7JBYJJJJJJ?~^~YJ7??7~!J??JJJJJJG&@[email protected]@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@&[email protected]@#????!^77?7??????!:[email protected]@@J77#&&@&B5YB#&@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@[email protected]~^[email protected]#@@@#7B&[email protected]@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@[email protected]#B&BG?~^7?J?77??7?JJ~^??JG#&B#@#[email protected]@#7B&[email protected]@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@[email protected]~!7????7!~7JYYY555G#@@[email protected]@#7B&[email protected]@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@[email protected]@@@@@@@B5!!7??7~!5#@@@@@@&G#@@[email protected]@#7B&[email protected]@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@[email protected]#BYYYYYYYYYJ7~^^~7JYYYYYYYYYB&@@@&J7?##7B&[email protected]@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@[email protected]@@@@@@@@@GJ^^^[email protected]@@@@@@@&[email protected]@@@J7!5PP&&[email protected]@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@[email protected]&#YYYYYYYYY!!7^^7!7YYYYYYYYY#&@@@@[email protected]@[email protected]@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@[email protected]&&&&&&&@&[email protected]&&&&&&&&[email protected]@@@J7!7JBYJ&@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@55GGG5#@@[email protected]@@@@@@[email protected]@@@@@@@@@@@@@@@@@@@@@@@

*/

import "./deps.sol";
pragma solidity 0.8.7;

contract DerTodesking is ERC721Enumerable, Ownable, ERC2981PerTokenRoyalties {
    using Strings for uint256;

    uint256 public constant MAX_MINTABLE = 666; 
    uint256 public constant MAX_PER_CLAIM = 3;
    uint256 public constant NFT_PRICE = 0 ether; 
    uint256 public constant ROYALTY_VALUE = 690; 
    

    uint256 public minted = 0;
    bool public canClaim = true;
    bool public firstHour = false;
    bool public firstThirty = false;
    uint256 gross = 0;

    mapping(address => bool) admins;
    mapping(address => uint256) earlyMintAddresses;
    mapping(address => uint256) firstThirtyMinted;

    address royaltyRecipient; //0xF246AA79913744461E169907Bd4a865b8637f5e2
    string baseUri; // https://der-todesking.nyc3.digitaloceanspaces.com/json/

    // random token id map
    mapping(uint256 => uint256) indexer;
    uint256 indexerLength = MAX_MINTABLE;
    mapping(uint256 => uint256) tokenIDMap;
    mapping(uint256 => uint256) takenImages;

    event Claim(uint256 indexed _id);


    constructor(
        string memory nftName,
        string memory nftSymbol,
        string memory baseTokenURI,
        address _royaltyRecipient
    ) ERC721(nftName, nftSymbol) Ownable() {
        royaltyRecipient = _royaltyRecipient;
        baseUri = baseTokenURI;
    }

/////////////////////////////////////////////////////////
//
//
//                      MINT 
//
//
//

    
    function getNextImageID(uint256 index) internal returns (uint256) {
        uint256 nextImageID = indexer[index];

        // if it's 0, means it hasn't been picked yet
        if (nextImageID == 0) {
            nextImageID = index;
        }
        // Swap last one with the picked one.
        // Last one can be a previously picked one as well, thats why we check
        if (indexer[indexerLength - 1] == 0) {
            indexer[index] = indexerLength - 1;
        } else {
            indexer[index] = indexer[indexerLength - 1];
        }
        indexerLength -= 1;
        return nextImageID;
    }

    function enoughRandom() internal view returns (uint256) {
        if (MAX_MINTABLE - minted == 0) return 0;
        return
            uint256(
                keccak256(
                    abi.encodePacked(
                        block.difficulty,
                        block.timestamp,
                        msg.sender,
                        blockhash(block.number)
                    )
                )
            ) % (indexerLength);
    }

    function randomMint(address receiver, uint256 nextTokenIndex) internal {
        uint256 nextIndexerId = enoughRandom();
        uint256 nextImageID = getNextImageID(nextIndexerId);

        assert(takenImages[nextImageID] == 0);
        takenImages[nextImageID] = 1;
        tokenIDMap[nextTokenIndex] = nextImageID;
        _safeMint(receiver, nextTokenIndex);
    }


    function mint(uint256 n) public payable {
        require(canClaim, "It's not possible to claim just yet.");
        require(n + minted <= MAX_MINTABLE, "Not enough left to mint.");
        require(n > 0, "Number need to be higher than 0");
        require(n <= MAX_PER_CLAIM, "Max per claim is 3");
        require(
            msg.value >= (NFT_PRICE * n),
            "Ether value sent is below the price"
        );

        if (firstHour){
            require(n <= 1, "Max per claim is 1 during the first hour");
            require(earlyMintAddresses[msg.sender] > 0, "You are not whitelisted");
            earlyMintAddresses[msg.sender] -= n;
        }

        if(firstThirty){
            require(n <= 10, "Max per claim is 10 NFTs per wallet");
            require(firstThirtyMinted[msg.sender] < 10, "10 NFTs per wallet");
            firstThirtyMinted[msg.sender] +=n;
        }

        uint256 total_cost = (NFT_PRICE * n);
        gross += total_cost;

        uint256 excess = msg.value - total_cost;
        payable(address(this)).transfer(total_cost);

        for (uint256 i = 0; i < n; i++) {
            randomMint(_msgSender(), minted);
            _setTokenRoyalty(minted, royaltyRecipient, ROYALTY_VALUE);

            minted += 1;
            emit Claim(minted);
        }

        if (excess > 0) {
            payable(_msgSender()).transfer(excess);
        }
    }


/////////////////////////////////////////////////////////
//
//
//                      Transfers
//
//
//

    function transferFrom(
        address from,
        address to,
        uint256 tokenId
    ) public virtual override {
        require(
            _isApprovedOrOwner(_msgSender(), tokenId),
            "ERC721: transfer caller is not owner nor approved"
        );

        _transfer(from, to, tokenId);
    }

    function safeTransferFrom(
        address from,
        address to,
        uint256 tokenId
    ) public virtual override {

        safeTransferFrom(from, to, tokenId, "");
    }

    function safeTransferFrom(
        address from,
        address to,
        uint256 tokenId,
        bytes memory _data
    ) public virtual override {
        require(
            _isApprovedOrOwner(_msgSender(), tokenId),
            "ERC721: transfer caller is not owner nor approved"
        );

        _safeTransfer(from, to, tokenId, _data);
    }

    function _beforeTokenTransfer(
        address from,
        address to,
        uint256 tokenId
    ) internal override(ERC721Enumerable) {
        super._beforeTokenTransfer(from, to, tokenId);
    }





/////////////////////////////////////////////////////////
//
//
//                       ERC 
//
//
//
    function tokenURI(uint256 tokenId)
        public
        view
        virtual
        override
        returns (string memory)
    {
        require(
            _exists(tokenId),
            "ERC721Metadata: URI query for nonexistent token"
        );
        string memory baseURI = _baseURI();
        uint256 imageID = tokenIDMap[tokenId];
        return
            bytes(baseURI).length > 0
                ? string(abi.encodePacked(baseURI, imageID.toString(),".json"))
                : "";
    }

    function _baseURI() internal view override returns (string memory) {
        return baseUri;
    }

    /// @inheritdoc	ERC165
    function supportsInterface(bytes4 interfaceId)
        public
        view
        virtual
        override(ERC2981Base, ERC721Enumerable)
        returns (bool)
    {
        return super.supportsInterface(interfaceId);
    }


/////////////////////////////////////////////////////////
//
//
//                      UTILITIES 
//
//
//
   function withdraw() public payable onlyOwner {
    (bool os, ) = payable(owner()).call{value: address(this).balance}("");
    require(os);
  }

   // withdrawall addresses
  address t1 = 0xF246AA79913744461E169907Bd4a865b8637f5e2; 
  address t2 = 0xF246AA79913744461E169907Bd4a865b8637f5e2; 
  
  

  function withdrawall() public onlyOwner {
        uint256 _balance = address(this).balance;
        uint256 _split = _balance / 2;

        require(payable(t1).send(_split));
        require(payable(t2).send(_split));
        
  }


/////////////////////////////////////////////////////////
//
//
//                      SETTERS 
//
//
//


    function setAdmins(address[] calldata _addr) external onlyOwner{
        for (uint i=0; i<_addr.length ; i++){
            admins[_addr[i]] = true;
        }
    }
    function setRoyaltyAddress(address _royaltyRecipient) external onlyOwner {
        royaltyRecipient = _royaltyRecipient;
    }

    function setBaseUri(string memory uri) external onlyOwner {
        baseUri = uri;
    }

    function toggleClaimability() external onlyOwner {
        canClaim = !canClaim;
    }

    function toggleFirstHour() external onlyOwner {
        firstHour = !firstHour;
    }

    function toggleFirstThirty() external onlyOwner {
        firstThirty = !firstThirty;
    }

    function setEarlyMinters(
        address[] calldata addresses,
        uint256 allowedToMint
    ) external onlyOwner {
        for (uint256 i = 0; i < addresses.length; i++) {
            earlyMintAddresses[addresses[i]] = allowedToMint;
        }
    }

    function removeEarlyUser(address _addressToWhitelist) external onlyOwner {
        earlyMintAddresses[_addressToWhitelist] = 0;
    }


/////////////////////////////////////////////////////////
//
//
//                      GETTERS 
//
//
//

    function getAdmins(address _addr) public view onlyOwner returns(bool){
            return admins[_addr];
    }

    function isEarlyMinter(address _whitelistedAddress)
        public
        view
        returns (uint256)
    {
        uint256 userIsWhitelisted = earlyMintAddresses[_whitelistedAddress];
        return userIsWhitelisted;
    }

    function isThirtyMinter(address _whitelistedAddress)
        public
        view
        returns (uint256)
    {
        uint256 userIsWhitelisted = firstThirtyMinted[_whitelistedAddress];
        return userIsWhitelisted;
    }

    receive() external payable {}

    fallback() external payable {}
}
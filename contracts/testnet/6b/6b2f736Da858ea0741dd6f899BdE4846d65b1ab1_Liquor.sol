// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)

pragma solidity ^0.8.0;

import "../utils/Context.sol";

/**
 * @dev Contract module which provides a basic access control mechanism, where
 * there is an account (an owner) that can be granted exclusive access to
 * specific functions.
 *
 * By default, the owner account will be the one that deploys the contract. This
 * can later be changed with {transferOwnership}.
 *
 * This module is used through inheritance. It will make available the modifier
 * `onlyOwner`, which can be applied to your functions to restrict their use to
 * the owner.
 */
abstract contract Ownable is Context {
    address private _owner;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    /**
     * @dev Initializes the contract setting the deployer as the initial owner.
     */
    constructor() {
        _transferOwnership(_msgSender());
    }

    /**
     * @dev Throws if called by any account other than the owner.
     */
    modifier onlyOwner() {
        _checkOwner();
        _;
    }

    /**
     * @dev Returns the address of the current owner.
     */
    function owner() public view virtual returns (address) {
        return _owner;
    }

    /**
     * @dev Throws if the sender is not the owner.
     */
    function _checkOwner() internal view virtual {
        require(owner() == _msgSender(), "Ownable: caller is not the owner");
    }

    /**
     * @dev Leaves the contract without owner. It will not be possible to call
     * `onlyOwner` functions anymore. Can only be called by the current owner.
     *
     * NOTE: Renouncing ownership will leave the contract without an owner,
     * thereby removing any functionality that is only available to the owner.
     */
    function renounceOwnership() public virtual onlyOwner {
        _transferOwnership(address(0));
    }

    /**
     * @dev Transfers ownership of the contract to a new account (`newOwner`).
     * Can only be called by the current owner.
     */
    function transferOwnership(address newOwner) public virtual onlyOwner {
        require(newOwner != address(0), "Ownable: new owner is the zero address");
        _transferOwnership(newOwner);
    }

    /**
     * @dev Transfers ownership of the contract to a new account (`newOwner`).
     * Internal function without access restriction.
     */
    function _transferOwnership(address newOwner) internal virtual {
        address oldOwner = _owner;
        _owner = newOwner;
        emit OwnershipTransferred(oldOwner, newOwner);
    }
}

// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)

pragma solidity ^0.8.0;

/**
 * @dev Provides information about the current execution context, including the
 * sender of the transaction and its data. While these are generally available
 * via msg.sender and msg.data, they should not be accessed in such a direct
 * manner, since when dealing with meta-transactions the account sending and
 * paying for execution may not be the actual sender (as far as an application
 * is concerned).
 *
 * This contract is only required for intermediate, library-like contracts.
 */
abstract contract Context {
    function _msgSender() internal view virtual returns (address) {
        return msg.sender;
    }

    function _msgData() internal view virtual returns (bytes calldata) {
        return msg.data;
    }
}

// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/Math.sol)

pragma solidity ^0.8.0;

/**
 * @dev Standard math utilities missing in the Solidity language.
 */
library Math {
    enum Rounding {
        Down, // Toward negative infinity
        Up, // Toward infinity
        Zero // Toward zero
    }

    /**
     * @dev Returns the largest of two numbers.
     */
    function max(uint256 a, uint256 b) internal pure returns (uint256) {
        return a > b ? a : b;
    }

    /**
     * @dev Returns the smallest of two numbers.
     */
    function min(uint256 a, uint256 b) internal pure returns (uint256) {
        return a < b ? a : b;
    }

    /**
     * @dev Returns the average of two numbers. The result is rounded towards
     * zero.
     */
    function average(uint256 a, uint256 b) internal pure returns (uint256) {
        // (a + b) / 2 can overflow.
        return (a & b) + (a ^ b) / 2;
    }

    /**
     * @dev Returns the ceiling of the division of two numbers.
     *
     * This differs from standard division with `/` in that it rounds up instead
     * of rounding down.
     */
    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {
        // (a + b - 1) / b can overflow on addition, so we distribute.
        return a == 0 ? 0 : (a - 1) / b + 1;
    }

    /**
     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0
     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)
     * with further edits by Uniswap Labs also under MIT license.
     */
    function mulDiv(
        uint256 x,
        uint256 y,
        uint256 denominator
    ) internal pure returns (uint256 result) {
        unchecked {
            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use
            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256
            // variables such that product = prod1 * 2^256 + prod0.
            uint256 prod0; // Least significant 256 bits of the product
            uint256 prod1; // Most significant 256 bits of the product
            assembly {
                let mm := mulmod(x, y, not(0))
                prod0 := mul(x, y)
                prod1 := sub(sub(mm, prod0), lt(mm, prod0))
            }

            // Handle non-overflow cases, 256 by 256 division.
            if (prod1 == 0) {
                return prod0 / denominator;
            }

            // Make sure the result is less than 2^256. Also prevents denominator == 0.
            require(denominator > prod1);

            ///////////////////////////////////////////////
            // 512 by 256 division.
            ///////////////////////////////////////////////

            // Make division exact by subtracting the remainder from [prod1 prod0].
            uint256 remainder;
            assembly {
                // Compute remainder using mulmod.
                remainder := mulmod(x, y, denominator)

                // Subtract 256 bit number from 512 bit number.
                prod1 := sub(prod1, gt(remainder, prod0))
                prod0 := sub(prod0, remainder)
            }

            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.
            // See https://cs.stackexchange.com/q/138556/92363.

            // Does not overflow because the denominator cannot be zero at this stage in the function.
            uint256 twos = denominator & (~denominator + 1);
            assembly {
                // Divide denominator by twos.
                denominator := div(denominator, twos)

                // Divide [prod1 prod0] by twos.
                prod0 := div(prod0, twos)

                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.
                twos := add(div(sub(0, twos), twos), 1)
            }

            // Shift in bits from prod1 into prod0.
            prod0 |= prod1 * twos;

            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such
            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for
            // four bits. That is, denominator * inv = 1 mod 2^4.
            uint256 inverse = (3 * denominator) ^ 2;

            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works
            // in modular arithmetic, doubling the correct bits in each step.
            inverse *= 2 - denominator * inverse; // inverse mod 2^8
            inverse *= 2 - denominator * inverse; // inverse mod 2^16
            inverse *= 2 - denominator * inverse; // inverse mod 2^32
            inverse *= 2 - denominator * inverse; // inverse mod 2^64
            inverse *= 2 - denominator * inverse; // inverse mod 2^128
            inverse *= 2 - denominator * inverse; // inverse mod 2^256

            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.
            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is
            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1
            // is no longer required.
            result = prod0 * inverse;
            return result;
        }
    }

    /**
     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.
     */
    function mulDiv(
        uint256 x,
        uint256 y,
        uint256 denominator,
        Rounding rounding
    ) internal pure returns (uint256) {
        uint256 result = mulDiv(x, y, denominator);
        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {
            result += 1;
        }
        return result;
    }

    /**
     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.
     *
     * Inspired by Henry S. Warren, Jr.'s "Hacker's Delight" (Chapter 11).
     */
    function sqrt(uint256 a) internal pure returns (uint256) {
        if (a == 0) {
            return 0;
        }

        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.
        //
        // We know that the "msb" (most significant bit) of our target number `a` is a power of 2 such that we have
        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.
        //
        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`
        // → `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`
        // → `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`
        //
        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.
        uint256 result = 1 << (log2(a) >> 1);

        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,
        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at
        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision
        // into the expected uint128 result.
        unchecked {
            result = (result + a / result) >> 1;
            result = (result + a / result) >> 1;
            result = (result + a / result) >> 1;
            result = (result + a / result) >> 1;
            result = (result + a / result) >> 1;
            result = (result + a / result) >> 1;
            result = (result + a / result) >> 1;
            return min(result, a / result);
        }
    }

    /**
     * @notice Calculates sqrt(a), following the selected rounding direction.
     */
    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {
        unchecked {
            uint256 result = sqrt(a);
            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);
        }
    }

    /**
     * @dev Return the log in base 2, rounded down, of a positive value.
     * Returns 0 if given 0.
     */
    function log2(uint256 value) internal pure returns (uint256) {
        uint256 result = 0;
        unchecked {
            if (value >> 128 > 0) {
                value >>= 128;
                result += 128;
            }
            if (value >> 64 > 0) {
                value >>= 64;
                result += 64;
            }
            if (value >> 32 > 0) {
                value >>= 32;
                result += 32;
            }
            if (value >> 16 > 0) {
                value >>= 16;
                result += 16;
            }
            if (value >> 8 > 0) {
                value >>= 8;
                result += 8;
            }
            if (value >> 4 > 0) {
                value >>= 4;
                result += 4;
            }
            if (value >> 2 > 0) {
                value >>= 2;
                result += 2;
            }
            if (value >> 1 > 0) {
                result += 1;
            }
        }
        return result;
    }

    /**
     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.
     * Returns 0 if given 0.
     */
    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {
        unchecked {
            uint256 result = log2(value);
            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);
        }
    }

    /**
     * @dev Return the log in base 10, rounded down, of a positive value.
     * Returns 0 if given 0.
     */
    function log10(uint256 value) internal pure returns (uint256) {
        uint256 result = 0;
        unchecked {
            if (value >= 10**64) {
                value /= 10**64;
                result += 64;
            }
            if (value >= 10**32) {
                value /= 10**32;
                result += 32;
            }
            if (value >= 10**16) {
                value /= 10**16;
                result += 16;
            }
            if (value >= 10**8) {
                value /= 10**8;
                result += 8;
            }
            if (value >= 10**4) {
                value /= 10**4;
                result += 4;
            }
            if (value >= 10**2) {
                value /= 10**2;
                result += 2;
            }
            if (value >= 10**1) {
                result += 1;
            }
        }
        return result;
    }

    /**
     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.
     * Returns 0 if given 0.
     */
    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {
        unchecked {
            uint256 result = log10(value);
            return result + (rounding == Rounding.Up && 10**result < value ? 1 : 0);
        }
    }

    /**
     * @dev Return the log in base 256, rounded down, of a positive value.
     * Returns 0 if given 0.
     *
     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.
     */
    function log256(uint256 value) internal pure returns (uint256) {
        uint256 result = 0;
        unchecked {
            if (value >> 128 > 0) {
                value >>= 128;
                result += 16;
            }
            if (value >> 64 > 0) {
                value >>= 64;
                result += 8;
            }
            if (value >> 32 > 0) {
                value >>= 32;
                result += 4;
            }
            if (value >> 16 > 0) {
                value >>= 16;
                result += 2;
            }
            if (value >> 8 > 0) {
                result += 1;
            }
        }
        return result;
    }

    /**
     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.
     * Returns 0 if given 0.
     */
    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {
        unchecked {
            uint256 result = log256(value);
            return result + (rounding == Rounding.Up && 1 << (result * 8) < value ? 1 : 0);
        }
    }
}

//SPDX-License-Identifier: UNLICENSED
pragma solidity 0.8.18;

contract Constant {
    uint256 public constant WATER_DEFAULT_PRICE = 1_000_000;
    uint256 public constant CONVERT_PRECISION = 1e6;
    uint256 public constant MAX_BPS = 100_000;
    uint256 public constant COOLDOWN_PERIOD = 3 days;
    uint256 internal constant RATE_PRECISION = 1e30;
    uint8 public constant VLP_DECIMAL = 18;
}

//SPDX-License-Identifier: UNLICENSED
pragma solidity 0.8.18;

import {IBartender, IERC20, UserDepositInfo, SakeVaultInfo, UpdatedDebtRatio} from "../interfaces/IBartender.sol";
import {Constant} from "../access/Constant.sol";
import {Sake} from "./Sake.sol";
import {IWater} from "../interfaces/IWater.sol";
// import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import {Ownable} from "@openzeppelin/contracts/access/Ownable.sol";
import {Math} from "@openzeppelin/contracts/utils/math/Math.sol";

error NotAKeeper();
error ThrowInvalidAmount();
error ThrowLiquidationThresholdHasNotReached();

contract Liquor is Ownable, Constant {
    using Math for uint256;

    event Liquidate(
        uint256 SakeVaultId,
        address SakeVaultAddress,
        uint256 AmountToSakeUsers,
        uint256 amountToSafe,
        uint256 outstandingAmountToWater
    );
    IBartender public bartender;
    IWater public water;
    IERC20 public usdcToken;
    address public keeper;

    mapping(address => mapping(uint256 => uint256)) public withdrawableAmount;

    constructor(address _usdcToken, address _water, address _keeper) {
        usdcToken = IERC20(_usdcToken);
        water = IWater(_water);
        keeper = _keeper;
    }

    function setBartender(address _bartender) external onlyOwner {
        bartender = IBartender(_bartender);
    }

    function setKeeper(address _keeper) external onlyOwner {
        keeper = _keeper;
    }

    modifier onlyKeeper() {
        if (keeper != msg.sender) revert NotAKeeper();
        _;
    }

    function liquidateSakeVault(
        uint256 _id
    ) public onlyKeeper returns (uint256 AmountToSakeUsers, uint256 amountToSafe, uint256 outstandingAmountToWater) {
        UpdatedDebtRatio memory debtInfo = getDebtInfo(_id);
        // check if the liquidation threshold has reached
        if (debtInfo.newRatio < (90 * RATE_PRECISION) / 100) {
            revert ThrowLiquidationThresholdHasNotReached();
        }

        SakeVaultInfo memory sakeInfo = bartender.getSakeVaultInfo(_id);
        Sake sake = Sake(bartender.getSakeAddress(_id));
        // sell all VLP for the sub sake
        (, uint256 usdcAmount) = sake.withdraw(address(this), sakeInfo.totalAmountOfVLP);
        bartender.setLiquidated(_id);
        usdcToken.approve(address(water), usdcAmount);

        //if liquidation > debt:
        // repay all the debt, record the remaining balance;
        // check the debt balance of the sub-sake;
        if (usdcAmount >= debtInfo.newDebt) {
            water.repayDebt(debtInfo.newDebt);
            amountToSafe = (usdcToken.balanceOf(address(this)) / 2);
            usdcToken.transfer(keeper, amountToSafe);
            AmountToSakeUsers = (usdcToken.balanceOf(address(this)));

            uint256 length = sakeInfo.users.length;
            for (uint256 i; i < length; ) {
                address sakeUser = sakeInfo.users[i];
                uint256 userShares = getUserShares(_id, sakeUser);
                recordLiquidatedValue(_id, sakeUser, userShares, AmountToSakeUsers);

                {
                    unchecked {
                        i++;
                    }
                }
            }
            //@todo clean up all the states in userDepositInfo and SakeInfo, or add a boolean to disable all withdrawal
            //@todo may change to a safe instead of the keeper;

            emit Liquidate(_id, bartender.getSakeAddress(_id), AmountToSakeUsers, amountToSafe, 0);

            return (AmountToSakeUsers, amountToSafe, 0);
        } else {
            //if liquidation < debt;
            // pay the debt, safe transfer additional amount;
            water.repayDebt(usdcAmount);
            outstandingAmountToWater = debtInfo.newDebt - usdcAmount;
            //@todo Safe should deposit the outstandingAmount to water vault directly.
            return (0, 0, outstandingAmountToWater);
        }
    }

    function getDebtInfo(uint256 _id) public view returns (UpdatedDebtRatio memory debtInfo) {
        return bartender.getDebtInfo(_id);
    }

    function getDTVRatio(uint256 _id) public view returns (uint256 dtvRatio) {
        return bartender.getDebtInfo(_id).newRatio;
    }

    function getSakeUsers(uint256 _id) public view returns (address[] memory) {
        SakeVaultInfo memory sakeInfo = bartender.getSakeVaultInfo(_id);

        return sakeInfo.users;
    }

    function getUserShares(uint256 _id, address _user) public view returns (uint256 shares) {
        UserDepositInfo memory userInfo = bartender.depositInfo(_id, _user);

        return userInfo.shares;
    }

    function recordLiquidatedValue(uint256 _id, address _user, uint256 shares, uint256 totalAmount) internal {
        uint256 _amount = shares.mulDiv(totalAmount, RATE_PRECISION);

        withdrawableAmount[_user][_id] = _amount;

        // usdcToken.transfer(_user, _amount);
    }

    //user withdrawal on liquidation
    function withdraw(uint256 _id) public returns (uint256 wihtdrawnAmount) {
        uint256 amount = withdrawableAmount[msg.sender][_id];
        if (amount == 0) {
            revert ThrowInvalidAmount();
        } else {
            (address feeRecipient, bool feeEnabled, uint96 feeBPS) = getFeeStatus();
            if (!feeEnabled) {
                withdrawableAmount[msg.sender][_id] = 0;
                usdcToken.transfer(msg.sender, amount);
            } else {
                uint256 fee = amount.mulDiv(feeBPS, MAX_BPS);
                amount -= fee;
                withdrawableAmount[msg.sender][_id] = 0;
                usdcToken.transfer(feeRecipient, fee);
                usdcToken.transfer(msg.sender, amount);
            }
        }
        return amount;
    }

    function getAmountAfterLiquidation(uint256 _id, address user) public view returns (uint256) {
        return withdrawableAmount[user][_id];
    }

    function getFeeStatus() public view returns (address feeRecipient, bool feeEnabled, uint96 feeBps) {
        return bartender.getFeeStatus();
    }
}

//SPDX-License-Identifier: UNLICENSED
pragma solidity 0.8.18;

import {IERC20} from "../interfaces/IERC20.sol";
import {IVault} from "../interfaces/vela-exchange/IVault.sol";
import {ITokenFarm} from "../interfaces/vela-exchange/ITokenFarm.sol";

/**
 * @author Chef Photons, Vaultka Team serving high quality drinks; drink responsibly.
 * Responsible for to keeping track of our finest Sake
 */
contract Sake {
    IERC20 private immutable usdcToken;
    address private immutable bartender;
    uint256 private totalAmountOfVLP;
    address private liquor;

    //vela exchange contracts
    //will keep these
    IVault private immutable velaMintBurnVault;
    ITokenFarm private immutable velaStakingVault;
    IERC20 private immutable vlp;

    event Withdraw(address indexed _user, uint256 _amount);

    error ThrowPermissionDenied(address admin, address sender);

    modifier onlyBartenderOrLiquor() {
        if (msg.sender != address(bartender) && msg.sender != address(liquor))
            revert ThrowPermissionDenied({admin: address(bartender), sender: msg.sender});
        _;
    }

    constructor(
        address _usdcToken,
        address _bartender,
        address _velaMintBurnVault,
        address _velaStakingVault,
        address _vlp,
        address _liquor
    ) {
        usdcToken = IERC20(_usdcToken);
        bartender = _bartender;
        velaMintBurnVault = IVault(_velaMintBurnVault);
        velaStakingVault = ITokenFarm(_velaStakingVault);
        vlp = IERC20(_vlp);
        liquor = _liquor;
    }

    //@todo some approval needs to be grant for deposit and withdrawal, will work on that later
    /// @notice allows bartender to mint and stake vlp into the sake contract
    /// @return status status is true if the function executed sucessfully, vice versa
    function executeMintAndStake() external onlyBartenderOrLiquor returns (bool status, uint256 totalVLP) {
        uint256 usdcBalance = usdcToken.balanceOf(address(this));
        usdcToken.approve(address(velaMintBurnVault), usdcBalance);
        // vlp approve staking vault with uint256 max
        vlp.approve(address(velaStakingVault), type(uint256).max);
        //mint the whole batch of USDC to VLP, sake doesn't handle the accounting, so balanceOf will be sufficient.
        // @notice there is no need for reentrancy guard Bartender will handle that
        // REFERENCE: 01
        // @todo a struct/variables to store or return this values so that bartender can store them to calculate user share during withdrawal
        // vlp recieved,
        // amount used to purchase the vlp, (can be excluded since it amount transfered by bartender to sake)
        // price at which vlp was bought
        velaMintBurnVault.stake(address(this), address(usdcToken), usdcBalance);
        // get the total amount of VLP bought
        totalVLP = vlp.balanceOf(address(this));
        totalAmountOfVLP = totalVLP;
        velaStakingVault.deposit(0, totalVLP);

        return (true, totalVLP);
    }

    /// @notice allows bartender to withdraw a specific amount from the sake contract
    /// @param _to user reciving the redeemed USDC
    /// @param amountToWithdrawInVLP amount to withdraw in VLP
    /// @return status received in exchange of token
    function withdraw(
        address _to,
        uint256 amountToWithdrawInVLP
    ) external onlyBartenderOrLiquor returns (bool status, uint256 usdcAmount) {
        vlp.approve(address(velaStakingVault), amountToWithdrawInVLP);
        velaStakingVault.withdraw(0, amountToWithdrawInVLP);
        velaMintBurnVault.unstake(address(usdcToken), amountToWithdrawInVLP, address(this));
        uint256 withdrawAmount = usdcToken.balanceOf(address(this));

        //sake will send the USDC back to the user directly
        usdcToken.transfer(_to, withdrawAmount);
        return (true, withdrawAmount);
    }

    // create a function to output sake balance in vlp
    function getSakeBalanceInVLP() external view returns (uint256 vlpBalance) {
        return totalAmountOfVLP;
    }

    function getClaimable() public view returns (uint256) {
        return velaStakingVault.claimable(address(this));
    }

    function withdrawVesting() external onlyBartenderOrLiquor {
        velaStakingVault.withdrawVesting();
    }
}

//SPDX-License-Identifier: UNLICENSED
pragma solidity 0.8.18;

// import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import {IERC20} from "./IERC20.sol";

/* ##################################################################
                            STRUCTS
################################################################## */
struct UserDepositInfo {
    // Amount in supply as debt to SAKE
    uint256 amount;
    // max withdrawal amount
    uint256 maxWithdrawalAmount;
    uint256 totalWithdrawn;
    // store user shares
    uint256 shares;
    // track user withdrawal
    uint256 initializedShareStates;
}

struct UpdatedDebtRatio {
    uint256 newValue;
    uint256 newDebt;
    uint256 newRatio;
    uint256 lastUpdateTime;
    uint256 previousPrice;
}

struct SakeVaultInfo {
    bool isLiquidated;
    // total amount of USDC use to purchase VLP
    uint256 leverage;
    // record total amount of VLP
    uint256 totalAmountOfVLP;
    uint256 totalAmountOfVLPInUSDC;
    // get all deposited without leverage
    uint256 totalAmountOfUSDCWithoutLeverage;
    // store puchase price of VLP
    uint256 purchasePrice;
    // store all users in array
    address[] users;
    // store time when the sake vault is created
    uint256 startTime;
}

/**
 * @author Chef Photons, Vaultka Team serving high quality drinks; drink responsibly.
 * Factory and global config params
 */
interface IBartender {
    /* ##################################################################
                                EVENTS
    ################################################################## */
    /**
     * @dev Emitted when new `sake` contract is created by the keeper
     * with it `associatedTime`
     */
    event CreateNewSAKE(address indexed sake, uint256 indexed associatedTime);
    /**
     * @dev Emitted when new `supply` is provided and is required to be updated with `value`
     */
    event SettingManager(bytes32 supply, address value);
    /**
     * @dev Emitted when new `supply` is provided and is required to be updated with `value`
     */
    event SettingManagerForBool(bytes32 supply, bool value);

    /**
     * @dev Emitted when new `supply` is required to be updated with `value`
     */
    event SettingManagerForTripleSlope(bytes32 supply, uint256 value);

    /**
     * @dev Emitted when user deposited into the vault
     * `user` is the msg.sender
     * `amountDeposited` is the amount user deposited
     * `associatedTime` the time at which the deposit is made
     * `leverageFromWater` how much leverage was taking by the user from the WATER VAULT
     */
    event BartenderDeposit(
        address indexed user,
        uint256 amountDeposited,
        uint256 indexed associatedTime,
        uint256 indexed leverageFromWater
    );
    /**
     * @dev Emitted when user withdraw from the vault
     * `user` is the msg.sender
     * `amount` is the amount user withdraw
     * `sakeId` the id that identify each sake
     * `withdrawableAmountInVLP` how much vlp was taking and been sold for USDC
     */
    event Withdraw(
        address indexed user,
        uint256 indexed amount,
        uint256 sakeId,
        uint256 indexed withdrawableAmountInVLP
    );
    /**
     * @dev Emitted when there is need to update protocol fee
     * `feeEnabled` state of protocol fee
     */
    event ProtocolFeeStatus(bool indexed feeEnabled);
    /* ##################################################################
                                CUSTOM ERRORS
    ################################################################## */
    /// @notice Revert when caller is not SAKE
    error BTDNotSAKE();

    /// @notice Revert when caller is not Admin
    error BTDNotAKeeper();

    /// @notice Revert when caller is not Liquor
    error BTDNotLiquor();

    /// @notice Revert when input amount is zero
    error ThrowZeroAmount();

    /// @notice Revert when max deposit is exceeded
    error ThrowMaxDepositExceeded();

    /// @notice Revert when sake vault is liquidated
    error ThrowLiquidated();
    /// @notice Revert when New SAKE is not successfully created
    error UnsuccessfulCreationOfSake();

    /// @notice Revert when there is no deposit and new SAKE want to be created.
    error CurrentDepositIsZero();

    /// @notice Revert when invalid parameter is supply during
    error InvalidParameter(bytes32);

    /// @notice Revert set fee is greated than maximum fee (MAX_BPS)
    error InvalidFeeBps();

    /// @notice Revert when protocol fee is already in the current state of fee
    // error FeeAlreadySet();

    /// @notice Invalid address provided
    error ThrowZeroAddress();

    /// @notice Revert when lock time is on
    error ThrowLockTimeOn();

    /// @notice Revert when amount supplied is greater than locked amount
    error ThrowInvalidAmount();

    /// @notice Revert when amount supplied is greater than locked amount
    error SakeWitdrawal(address sake, uint256 amount);

    /// @notice Revert when the utilization ratio is greater than optimal utilization
    error ThrowOptimalUtilization();

    /// @dev When the value is greater than `MAX_BPS`
    error ThrowInvalidValue();

    // revrt when there is high utilization ratio
    error ThrowHighUtilizationRatio();

    /// @dev available params: `optimalUtilization`, `maxFeeSplitSlope1`,
    /// `maxFeeSplitSlope2`, `maxFeeSplitSLope3`, `utilizationThreshold1`,
    /// `utilizationThreshold2`, `utilizationThreshold3`
    /// @param params takes the bytes32 params name
    /// @param value takes the uint256 params value
    error ThrowInvalidParameter(bytes32 params, uint256 value);

    /// @notice deposit USDC into the Vault
    /// Requirements:
    /// {caller: anyone}.
    /// `_amount` it must be greater than 0.
    ///  user must have approve Bartender contract to spend USDC and allowance must be greater than `_amount`
    /// @param _amount amount in USDC msg.sender want to deposit to take leverage.
    /// @param _receiver recipient of $BARTENDER!.
    function deposit(uint256 _amount, address _receiver) external;

    /// @notice withdraw locked USDC from Vault
    /// Requirements:
    /// {caller: anyone}.
    /// `_amount` it must be greater than 0.
    /// `_amount` it must be less than amountDeposited.
    ///  withdrawal time must exceed numbers of time required to withdraw.
    ///  48 hours leverage must
    /// @param _amount amount in USDC msg.sender want to withdraw.
    /// @param _receiver address to recieve the `amount`.
    function withdraw(uint256 _amount, uint256 id, address _receiver) external;

    /// @notice gety current Id of BARTENDER! that has been minted
    /// @return uint256
    function getCurrentId() external view returns (uint256);

    function getSakeVaultInfo(uint256 id) external view returns (SakeVaultInfo memory);

    function depositInfo(uint256 id, address user) external view returns (UserDepositInfo memory);

    function getDebtInfo(uint256 id) external view returns (UpdatedDebtRatio memory);

    function getSakeAddress(uint256 id) external view returns (address);

    function setLiquidated(uint256 id) external returns (address sakeAddress);

    function getFeeStatus() external view returns (address, bool, uint96);
}

// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)

pragma solidity ^0.8.0;

/**
 * @dev Interface of the ERC20 standard as defined in the EIP.
 */
interface IERC20 {
    
    /**
     * @dev Returns the amount of tokens owned by `account`.
     */
    function balanceOf(address account) external view returns (uint256);

    /**
     * @dev Moves `amount` tokens from the caller's account to `to`.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * Emits a {Transfer} event.
     */
    function transfer(address to, uint256 amount) external returns (bool);

    /**
     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * IMPORTANT: Beware that changing an allowance with this method brings the risk
     * that someone may use both the old and the new allowance by unfortunate
     * transaction ordering. One possible solution to mitigate this race
     * condition is to first reduce the spender's allowance to 0 and set the
     * desired value afterwards:
     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
     *
     * Emits an {Approval} event.
     */
    function approve(address spender, uint256 amount) external returns (bool);

    /**
     * @dev Moves `amount` tokens from `from` to `to` using the
     * allowance mechanism. `amount` is then deducted from the caller's
     * allowance.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * Emits a {Transfer} event.
     */
    function transferFrom(
        address from,
        address to,
        uint256 amount
    ) external returns (bool);
}

//SPDX-License-Identifier: UNLICENSED
pragma solidity 0.8.18;

/**
 * @author Chef Photons, Vaultka Team serving high quality drinks; drink responsibly.
 * Responsible for our customers not getting intoxicated
 * @notice provided interface for `Water.sol`
 */
interface IWater {
    /* ##################################################################
                                EVENTS
    ################################################################## */
    
    /// @notice emit an event when user deposit USDC to the vault
    /// @param user the user address who deposit USDC
    /// @param amount the amount of USDC deposited (6 decimals)
    event WaterDeposit(address indexed user, uint256 amount);
    
    /// @notice emit an event when user withdraw USDC from the vault
    /// @param user the user address who withdraw USDC
    /// @param amount the amount of USDC withdrawn (6 decimals)
    event Withdrawal(address indexed user, uint256 amount);

    /// @notice update the address in setting manager
    /// @param params takes the bytes32 params name
    /// @param value takes the address params value
    event SettingManagerAddr(bytes32 params, address value);

    /// @notice update the uint256 in setting manager
    /// @param params takes the bytes32 params name
    /// @param value takes the uint256 params value
    event SettingManagerValue(bytes32 params, uint256 value);

    /// @notice the total amount of loan bartender makes
    /// @param amount total USDC amount to be transferred (6 decimals)
    /// @param timestamp the time that the leverage occured (seconds)
    event LeverageBartender(uint256 amount, uint256 timestamp);

    /// @notice the total amount of debt to be paid from bartender
    /// @param amount total USDC amount to be transferred (6 decimals)
    /// @param totalDebt total debt to be still be paid (6 decimals)
    /// @param timestamp the time that the debt been paid (seconds)
    event LeverageBartenderDebt(uint256 amount, uint256 totalDebt, uint256 timestamp);

    /* ##################################################################
                                ERRORS
    ################################################################## */
    /// @notice access control if can be access by the user
    /// @param admin the default address set
    /// @param sender `msg.sender` who is invoking the function
    error ThrowPermissionDenied(address admin, address sender);

    /// @notice 0x address / null address
    error ThrowZeroAddress();

    /// @notice 0 token is transferred
    error ThrowZeroAmount();

    /// @notice disabling ERC4626 functions
    error ThrowInvalidFunction();

    /// @dev available params: `bartender` and `fee`
    /// @param params takes the byets32 params name
    /// @param value takes the address params value
    error ThrowInvalidParamsAddr(bytes32 params, address value);

    /// @dev available params: `feeBPS and `cap`
    /// @param params takes the bytes32 params name
    /// @param value takes the uint256 params value
    error ThrowInvalidParamsValue(bytes32 params, uint256 value);

    /// @notice invalid contract address provided
    /// @param account address of the contract
    error ThrowInvalidContract(address account);

    /// @notice max deposit / withdraw that a user can make
    /// @dev if the cap is not set, this event will never be emitted (6 decimals)
    /// @param amount the total asset amount to preview (6 decimals)
    error ThrowAssetCap(uint256 amount, uint256 expected);

    /// @notice withdraw more than available USDC supply
    /// @param totalSupply supply of USDC (6 decimals)
    /// @param withdrawAmount amount wants to withdraw (6 decimals)
    error ThrowUnavailableSupply(uint256 totalSupply, uint256 withdrawAmount);

    /* ##################################################################
                                OWNERFUNCTIONS
    ################################################################## */
    /// @notice update the addresses necessary
    /// @param params bytes32 of the value to update
    /// @param value address of bytes32 to update with
    function settingManagerAddr(bytes32 params, address value) external;

    /// @notice update the values necessary
    /// @param params bytes32 of the values to update
    /// @param value uint256 of bytes32 to update with
    function settingManagerValue(bytes32 params, uint256 value) external;

    /* ##################################################################
                                BARTENDER FUNCTIONS
    ################################################################## */
    /// @notice supply USDC to the vault
    /// @param _amount to be leveraged to Bartender (6 decimals)
    function leverageVault(uint256 _amount) external;

    /// @notice collect debt from Bartender
    /// @param _amount to be collected from Bartender (6 decimals)
    function repayDebt(uint256 _amount) external;
    function getTotalDebt() external view returns (uint256);
}

// SPDX-License-Identifier: MIT
pragma solidity 0.8.18;

/**
 * @dev Interface of the VeDxp
 */
interface ITokenFarm {
    function deposit(uint256 _pid, uint256 _amount) external;

    function withdraw(uint256 _pid, uint256 _amount) external;

    function claimable(address _account) external view returns (uint256);

    function withdrawVesting() external;
}

// SPDX-License-Identifier: MIT

pragma solidity 0.8.18;

//@note this interface is actually for minting and burning, the function name is confusing
interface IVault {
    function stake(address _account, address _token, uint256 _amount) external;

    function unstake(address _tokenOut, uint256 _vlpAmount, address _receiver) external;

    function getVLPPrice() external view returns (uint256);
}
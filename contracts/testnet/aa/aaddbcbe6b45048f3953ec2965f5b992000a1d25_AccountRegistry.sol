// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.13;

import "./interfaces/IRegistry.sol";
import "./lib/MinimalProxyStore.sol";

/**
 * @title A registry for token bound accounts
 * @dev Determines the address for each token bound account and performs deployment of accounts
 * @author Jayden Windle (jaydenwindle)
 */
contract AccountRegistry is IRegistry {
    /**
     * @dev Address of the account implementation
     */
    address public immutable implementation;

    constructor(address _implementation) {
        implementation = _implementation;
    }

    /**
     * @dev Creates the account for an ERC721 token. Will revert if account has already been deployed
     *
     * @param chainId the chainid of the network the ERC721 token exists on
     * @param tokenCollection the contract address of the ERC721 token which will control the deployed account
     * @param tokenId the token ID of the ERC721 token which will control the deployed account
     * @return The address of the deployed ccount
     */
    function createAccount(uint256 chainId, address tokenCollection, uint256 tokenId) external returns (address) {
        return _createAccount(chainId, tokenCollection, tokenId);
    }

    /**
     * @dev Deploys the account for an ERC721 token. Will revert if account has already been deployed
     *
     * @param tokenCollection the contract address of the ERC721 token which will control the deployed account
     * @param tokenId the token ID of the ERC721 token which will control the deployed account
     * @return The address of the deployed account
     */
    function createAccount(address tokenCollection, uint256 tokenId) external returns (address) {
        return _createAccount(block.chainid, tokenCollection, tokenId);
    }

    /**
     * @dev Gets the address of the account for an ERC721 token. If account is
     * not yet deployed, returns the address it will be deployed to
     *
     * @param chainId the chainid of the network the ERC721 token exists on
     * @param tokenCollection the address of the ERC721 token contract
     * @param tokenId the tokenId of the ERC721 token that controls the account
     * @return The account address
     */
    function account(uint256 chainId, address tokenCollection, uint256 tokenId) external view returns (address) {
        return _account(chainId, tokenCollection, tokenId);
    }

    /**
     * @dev Gets the address of the account for an ERC721 token. If account is
     * not yet deployed, returns the address it will be deployed to
     *
     * @param tokenCollection the address of the ERC721 token contract
     * @param tokenId the tokenId of the ERC721 token that controls the account
     * @return The account address
     */
    function account(address tokenCollection, uint256 tokenId) external view returns (address) {
        return _account(block.chainid, tokenCollection, tokenId);
    }

    function _createAccount(uint256 chainId, address tokenCollection, uint256 tokenId) internal returns (address) {
        bytes memory encodedTokenData = abi.encode(chainId, tokenCollection, tokenId);
        bytes32 salt = keccak256(encodedTokenData);
        address accountProxy = MinimalProxyStore.cloneDeterministic(implementation, encodedTokenData, salt);

        emit AccountCreated(accountProxy, tokenCollection, tokenId);

        return accountProxy;
    }

    function _account(uint256 chainId, address tokenCollection, uint256 tokenId) internal view returns (address) {
        bytes memory encodedTokenData = abi.encode(chainId, tokenCollection, tokenId);
        bytes32 salt = keccak256(encodedTokenData);

        address accountProxy = MinimalProxyStore.predictDeterministicAddress(implementation, encodedTokenData, salt);

        return accountProxy;
    }
}

// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.13;

interface IRegistry {
    event AccountCreated(address account, address indexed tokenContract, uint256 indexed tokenId);

    function createAccount(address tokenContract, uint256 tokenId) external returns (address);

    function account(address tokenContract, uint256 tokenId) external view returns (address);
}

// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.13;

import "openzeppelin-contracts/utils/Create2.sol";
import "sstore2/utils/Bytecode.sol";

/**
 * @title A library for deploying EIP-1167 minimal proxy contracts with embedded constant data
 * @author Jayden Windle (jaydenwindle)
 */
library MinimalProxyStore {
    error CreateError();
    error ContextOverflow();

    /**
     * @dev Returns bytecode for a minmal proxy with additional context data appended to it
     *
     * @param implementation the implementation this proxy will delegate to
     * @param context the data to be appended to the proxy
     * @return the generated bytecode
     */
    function getBytecode(address implementation, bytes memory context) internal pure returns (bytes memory) {
        return abi.encodePacked(
            hex"3d61", // RETURNDATASIZE, PUSH2
            uint16(0x2d + context.length + 1), // size of minimal proxy (45 bytes) + size of context + stop byte
            hex"8060", // DUP1, PUSH1
            uint8(0x0a + 1), // default offset (0x0a) + 1 byte because we increased size from uint8 to uint16
            hex"3d3981f3363d3d373d3d3d363d73", // standard EIP1167 implementation
            implementation, // implementation address
            hex"5af43d82803e903d91602b57fd5bf3", // standard EIP1167 implementation
            hex"00", // stop byte (prevents context from executing as code)
            context // appended context data
        );
    }

    /**
     * @dev Fetches the context data stored in a deployed proxy
     *
     * @param instance the proxy to query context data for
     * @return the queried context data
     */
    function getContext(address instance) internal view returns (bytes memory) {
        uint256 instanceCodeLength = instance.code.length;

        return Bytecode.codeAt(instance, 46, instanceCodeLength);
    }

    /**
     * @dev Deploys and returns the address of a clone with stored context data that mimics the behaviour of `implementation`.
     *
     * This function uses the create opcode, which should never revert.
     *
     * @param implementation the implementation to delegate to
     * @param context context data to be stored in the proxy
     * @return instance the address of the deployed proxy
     */
    function clone(address implementation, bytes memory context) internal returns (address instance) {
        // Generate bytecode for proxy
        bytes memory code = getBytecode(implementation, context);

        // Deploy contract using create
        assembly {
            instance := create(0, add(code, 32), mload(code))
        }

        // If address is zero, deployment failed
        if (instance == address(0)) revert CreateError();
    }

    /**
     * @dev Deploys and returns the address of a clone with stored context data that mimics the behaviour of `implementation`.
     *
     * This function uses the create2 opcode and a `salt` to deterministically deploy
     * the clone. Using the same `implementation` and `salt` multiple time will revert, since
     * the clones cannot be deployed twice at the same address.
     *
     * @param implementation the implementation to delegate to
     * @param context context data to be stored in the proxy
     * @return instance the address of the deployed proxy
     */
    function cloneDeterministic(address implementation, bytes memory context, bytes32 salt)
        internal
        returns (address instance)
    {
        bytes memory code = getBytecode(implementation, context);

        // Deploy contract using create2
        assembly {
            instance := create2(0, add(code, 32), mload(code), salt)
        }

        // If address is zero, deployment failed
        if (instance == address(0)) revert CreateError();
    }

    /**
     * @dev Computes the address of a clone deployed using {MinimalProxyStore-cloneDeterministic}.
     */
    function predictDeterministicAddress(address implementation, bytes memory context, bytes32 salt, address deployer)
        internal
        pure
        returns (address predicted)
    {
        bytes memory code = getBytecode(implementation, context);

        return Create2.computeAddress(salt, keccak256(code), deployer);
    }

    /**
     * @dev Computes the address of a clone deployed using {MinimalProxyStore-cloneDeterministic}.
     */
    function predictDeterministicAddress(address implementation, bytes memory context, bytes32 salt)
        internal
        view
        returns (address predicted)
    {
        return predictDeterministicAddress(implementation, context, salt, address(this));
    }
}

// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts (last updated v4.9.0) (utils/Create2.sol)

pragma solidity ^0.8.0;

/**
 * @dev Helper to make usage of the `CREATE2` EVM opcode easier and safer.
 * `CREATE2` can be used to compute in advance the address where a smart
 * contract will be deployed, which allows for interesting new mechanisms known
 * as 'counterfactual interactions'.
 *
 * See the https://eips.ethereum.org/EIPS/eip-1014#motivation[EIP] for more
 * information.
 */
library Create2 {
    /**
     * @dev Deploys a contract using `CREATE2`. The address where the contract
     * will be deployed can be known in advance via {computeAddress}.
     *
     * The bytecode for a contract can be obtained from Solidity with
     * `type(contractName).creationCode`.
     *
     * Requirements:
     *
     * - `bytecode` must not be empty.
     * - `salt` must have not been used for `bytecode` already.
     * - the factory must have a balance of at least `amount`.
     * - if `amount` is non-zero, `bytecode` must have a `payable` constructor.
     */
    function deploy(uint256 amount, bytes32 salt, bytes memory bytecode) internal returns (address addr) {
        require(address(this).balance >= amount, "Create2: insufficient balance");
        require(bytecode.length != 0, "Create2: bytecode length is zero");
        /// @solidity memory-safe-assembly
        assembly {
            addr := create2(amount, add(bytecode, 0x20), mload(bytecode), salt)
        }
        require(addr != address(0), "Create2: Failed on deploy");
    }

    /**
     * @dev Returns the address where a contract will be stored if deployed via {deploy}. Any change in the
     * `bytecodeHash` or `salt` will result in a new destination address.
     */
    function computeAddress(bytes32 salt, bytes32 bytecodeHash) internal view returns (address) {
        return computeAddress(salt, bytecodeHash, address(this));
    }

    /**
     * @dev Returns the address where a contract will be stored if deployed via {deploy} from a contract located at
     * `deployer`. If `deployer` is this contract's address, returns the same value as {computeAddress}.
     */
    function computeAddress(bytes32 salt, bytes32 bytecodeHash, address deployer) internal pure returns (address addr) {
        /// @solidity memory-safe-assembly
        assembly {
            let ptr := mload(0x40) // Get free memory pointer

            // |                   | ↓ ptr ...  ↓ ptr + 0x0B (start) ...  ↓ ptr + 0x20 ...  ↓ ptr + 0x40 ...   |
            // |-------------------|---------------------------------------------------------------------------|
            // | bytecodeHash      |                                                        CCCCCCCCCCCCC...CC |
            // | salt              |                                      BBBBBBBBBBBBB...BB                   |
            // | deployer          | 000000...0000AAAAAAAAAAAAAAAAAAA...AA                                     |
            // | 0xFF              |            FF                                                             |
            // |-------------------|---------------------------------------------------------------------------|
            // | memory            | 000000...00FFAAAAAAAAAAAAAAAAAAA...AABBBBBBBBBBBBB...BBCCCCCCCCCCCCC...CC |
            // | keccak(start, 85) |            ↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑ |

            mstore(add(ptr, 0x40), bytecodeHash)
            mstore(add(ptr, 0x20), salt)
            mstore(ptr, deployer) // Right-aligned with 12 preceding garbage bytes
            let start := add(ptr, 0x0b) // The hashed data starts at the final garbage byte which we will set to 0xff
            mstore8(start, 0xff)
            addr := keccak256(start, 85)
        }
    }
}

// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;


library Bytecode {
  error InvalidCodeAtRange(uint256 _size, uint256 _start, uint256 _end);

  /**
    @notice Generate a creation code that results on a contract with `_code` as bytecode
    @param _code The returning value of the resulting `creationCode`
    @return creationCode (constructor) for new contract
  */
  function creationCodeFor(bytes memory _code) internal pure returns (bytes memory) {
    /*
      0x00    0x63         0x63XXXXXX  PUSH4 _code.length  size
      0x01    0x80         0x80        DUP1                size size
      0x02    0x60         0x600e      PUSH1 14            14 size size
      0x03    0x60         0x6000      PUSH1 00            0 14 size size
      0x04    0x39         0x39        CODECOPY            size
      0x05    0x60         0x6000      PUSH1 00            0 size
      0x06    0xf3         0xf3        RETURN
      <CODE>
    */

    return abi.encodePacked(
      hex"63",
      uint32(_code.length),
      hex"80_60_0E_60_00_39_60_00_F3",
      _code
    );
  }

  /**
    @notice Returns the size of the code on a given address
    @param _addr Address that may or may not contain code
    @return size of the code on the given `_addr`
  */
  function codeSize(address _addr) internal view returns (uint256 size) {
    assembly { size := extcodesize(_addr) }
  }

  /**
    @notice Returns the code of a given address
    @dev It will fail if `_end < _start`
    @param _addr Address that may or may not contain code
    @param _start number of bytes of code to skip on read
    @param _end index before which to end extraction
    @return oCode read from `_addr` deployed bytecode

    Forked from: https://gist.github.com/KardanovIR/fe98661df9338c842b4a30306d507fbd
  */
  function codeAt(address _addr, uint256 _start, uint256 _end) internal view returns (bytes memory oCode) {
    uint256 csize = codeSize(_addr);
    if (csize == 0) return bytes("");

    if (_start > csize) return bytes("");
    if (_end < _start) revert InvalidCodeAtRange(csize, _start, _end); 

    unchecked {
      uint256 reqSize = _end - _start;
      uint256 maxSize = csize - _start;

      uint256 size = maxSize < reqSize ? maxSize : reqSize;

      assembly {
        // allocate output byte array - this could also be done without assembly
        // by using o_code = new bytes(size)
        oCode := mload(0x40)
        // new "memory end" including padding
        mstore(0x40, add(oCode, and(add(add(size, 0x20), 0x1f), not(0x1f))))
        // store length in memory
        mstore(oCode, size)
        // actually retrieve the code, this needs assembly
        extcodecopy(_addr, add(oCode, 0x20), _start, size)
      }
    }
  }
}